---
layout: about.hbs
title: Про проект
trademark: Торгова марка
---

# Про Node.js®

Як асинхронне подієве JavaScript–оточення, Node.js спроектований для побудови
масштабованих мережевих додатків. У нижче наведений приклад "hello world", який
може одночасно обробляти багато з’єднань. Для кожного з’єднання викликається
функція зворотнього виклику, проте коли з’єднань немає Node.js засинає.

```javascript
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Це контрастує з більш загальною моделлю в якій використовуються паралельні OS
потоки. Такий підхід є відносно неефективним та дуже важким у використанні.
Більше того, користувачі Node.js можуть не турбуватись про блокування процесів,
оскільки немає жодних блокувань. Майже жодна з функцій у Node.js
не працює напряму з I/O, тому процес не блокується ніколи. Оскільки нічого
не блокується на Node.js легко розробляти масштабовані системи.

Якщо щось у цьому підході є незрозумілим для вас, то можете переглянути
повну статтю [Blocking vs Non-Blocking][].

---

Node.js створений під впливом таких систем як [Event Machine][] в Ruby або
[Twisted][] в Python. Node.js використовує подієву модель значно ширше,
він приймає [цикл подій (event loop)][] за основу оточення, замість того,
щоб використовувати його в якості бібліотеки. В інших системах завжди стається
блокування виклику, щоб запустити цикл подій.

Зазвичай поведінка визначається через функції зворотнього виклику на початку
скрипта і в кінці запускає сервер через блокуючий виклик,
як от `EventMachine::run()`. В Node.js немає нічого подібного на виклик початку
циклу подій. Node.js просто входить в подієвий цикл після запуску скрипта на
виконання. Node.js виходить з подієвого циклу тоді, коли не залишається
зареєстрованих функцій зворотнього виклику. Така поведінка схожа на поведінку
браузерного JavaScript: подієвий цикл прихований від користувача.

HTTP є об'єктом першого роду в Node.js, розробленим з потоковістю та малою затримкою. Це робить Node.js хорошою основою для веб–бібліотеки або фреймворку.

Те що Node.js спроектований без багатопоточності, не означає, що ви не можете
використовувати можливості кількох ядер у вашому середовищі. Ви можете
створювати дочірні процеси, якими легко керувати з допомогою API
[`child_process.fork()`][]. Модуль [`cluster`][] побудований на цьому
інтерфейсі і дозволяє вам ділитись сокетами між процесами та
розподіляти навантаження між ядрами.

[Blocking vs Non-Blocking]: /en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[цикл подій (event loop)]: /en/docs/guides/event-loop-timers-and-nexttick/
[Event Machine]: https://github.com/eventmachine/eventmachine
[Twisted]: https://twistedmatrix.com/trac/
